// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meet_msg.proto

#ifndef PROTOBUF_meet_5fmsg_2eproto__INCLUDED
#define PROTOBUF_meet_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common_msg.pb.h"
#include "meet_msg_type.pb.h"
// @@protoc_insertion_point(includes)

namespace pms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_meet_5fmsg_2eproto();
void protobuf_AssignDesc_meet_5fmsg_2eproto();
void protobuf_ShutdownFile_meet_5fmsg_2eproto();

class Login;
class Logout;
class Keep;
class MeetMsg;

// ===================================================================

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string usr_from = 1;
  inline bool has_usr_from() const;
  inline void clear_usr_from();
  static const int kUsrFromFieldNumber = 1;
  inline const ::std::string& usr_from() const;
  inline void set_usr_from(const ::std::string& value);
  inline void set_usr_from(const char* value);
  inline void set_usr_from(const char* value, size_t size);
  inline ::std::string* mutable_usr_from();
  inline ::std::string* release_usr_from();
  inline void set_allocated_usr_from(::std::string* usr_from);

  // optional string usr_token = 2;
  inline bool has_usr_token() const;
  inline void clear_usr_token();
  static const int kUsrTokenFieldNumber = 2;
  inline const ::std::string& usr_token() const;
  inline void set_usr_token(const ::std::string& value);
  inline void set_usr_token(const char* value);
  inline void set_usr_token(const char* value, size_t size);
  inline ::std::string* mutable_usr_token();
  inline ::std::string* release_usr_token();
  inline void set_allocated_usr_token(::std::string* usr_token);

  // optional string usr_nname = 3;
  inline bool has_usr_nname() const;
  inline void clear_usr_nname();
  static const int kUsrNnameFieldNumber = 3;
  inline const ::std::string& usr_nname() const;
  inline void set_usr_nname(const ::std::string& value);
  inline void set_usr_nname(const char* value);
  inline void set_usr_nname(const char* value, size_t size);
  inline ::std::string* mutable_usr_nname();
  inline ::std::string* release_usr_nname();
  inline void set_allocated_usr_nname(::std::string* usr_nname);

  // @@protoc_insertion_point(class_scope:pms.Login)
 private:
  inline void set_has_usr_from();
  inline void clear_has_usr_from();
  inline void set_has_usr_token();
  inline void clear_has_usr_token();
  inline void set_has_usr_nname();
  inline void clear_has_usr_nname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* usr_from_;
  ::std::string* usr_token_;
  ::std::string* usr_nname_;
  friend void  protobuf_AddDesc_meet_5fmsg_2eproto();
  friend void protobuf_AssignDesc_meet_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_meet_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class Logout : public ::google::protobuf::Message {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logout& default_instance();

  void Swap(Logout* other);

  // implements Message ----------------------------------------------

  Logout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string usr_from = 1;
  inline bool has_usr_from() const;
  inline void clear_usr_from();
  static const int kUsrFromFieldNumber = 1;
  inline const ::std::string& usr_from() const;
  inline void set_usr_from(const ::std::string& value);
  inline void set_usr_from(const char* value);
  inline void set_usr_from(const char* value, size_t size);
  inline ::std::string* mutable_usr_from();
  inline ::std::string* release_usr_from();
  inline void set_allocated_usr_from(::std::string* usr_from);

  // optional string usr_token = 2;
  inline bool has_usr_token() const;
  inline void clear_usr_token();
  static const int kUsrTokenFieldNumber = 2;
  inline const ::std::string& usr_token() const;
  inline void set_usr_token(const ::std::string& value);
  inline void set_usr_token(const char* value);
  inline void set_usr_token(const char* value, size_t size);
  inline ::std::string* mutable_usr_token();
  inline ::std::string* release_usr_token();
  inline void set_allocated_usr_token(::std::string* usr_token);

  // @@protoc_insertion_point(class_scope:pms.Logout)
 private:
  inline void set_has_usr_from();
  inline void clear_has_usr_from();
  inline void set_has_usr_token();
  inline void clear_has_usr_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* usr_from_;
  ::std::string* usr_token_;
  friend void  protobuf_AddDesc_meet_5fmsg_2eproto();
  friend void protobuf_AssignDesc_meet_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_meet_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Logout* default_instance_;
};
// -------------------------------------------------------------------

class Keep : public ::google::protobuf::Message {
 public:
  Keep();
  virtual ~Keep();

  Keep(const Keep& from);

  inline Keep& operator=(const Keep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Keep& default_instance();

  void Swap(Keep* other);

  // implements Message ----------------------------------------------

  Keep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Keep& from);
  void MergeFrom(const Keep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string usr_from = 1;
  inline bool has_usr_from() const;
  inline void clear_usr_from();
  static const int kUsrFromFieldNumber = 1;
  inline const ::std::string& usr_from() const;
  inline void set_usr_from(const ::std::string& value);
  inline void set_usr_from(const char* value);
  inline void set_usr_from(const char* value, size_t size);
  inline ::std::string* mutable_usr_from();
  inline ::std::string* release_usr_from();
  inline void set_allocated_usr_from(::std::string* usr_from);

  // @@protoc_insertion_point(class_scope:pms.Keep)
 private:
  inline void set_has_usr_from();
  inline void clear_has_usr_from();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* usr_from_;
  friend void  protobuf_AddDesc_meet_5fmsg_2eproto();
  friend void protobuf_AssignDesc_meet_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_meet_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Keep* default_instance_;
};
// -------------------------------------------------------------------

class MeetMsg : public ::google::protobuf::Message {
 public:
  MeetMsg();
  virtual ~MeetMsg();

  MeetMsg(const MeetMsg& from);

  inline MeetMsg& operator=(const MeetMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeetMsg& default_instance();

  void Swap(MeetMsg* other);

  // implements Message ----------------------------------------------

  MeetMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MeetMsg& from);
  void MergeFrom(const MeetMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pms.EMsgHead msg_head = 1 [default = HSND];
  inline bool has_msg_head() const;
  inline void clear_msg_head();
  static const int kMsgHeadFieldNumber = 1;
  inline ::pms::EMsgHead msg_head() const;
  inline void set_msg_head(::pms::EMsgHead value);

  // optional .pms.EMsgTag msg_tag = 2 [default = TCHAT];
  inline bool has_msg_tag() const;
  inline void clear_msg_tag();
  static const int kMsgTagFieldNumber = 2;
  inline ::pms::EMsgTag msg_tag() const;
  inline void set_msg_tag(::pms::EMsgTag value);

  // optional .pms.EMsgType msg_type = 3 [default = TMSG];
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 3;
  inline ::pms::EMsgType msg_type() const;
  inline void set_msg_type(::pms::EMsgType value);

  // optional string usr_from = 4;
  inline bool has_usr_from() const;
  inline void clear_usr_from();
  static const int kUsrFromFieldNumber = 4;
  inline const ::std::string& usr_from() const;
  inline void set_usr_from(const ::std::string& value);
  inline void set_usr_from(const char* value);
  inline void set_usr_from(const char* value, size_t size);
  inline ::std::string* mutable_usr_from();
  inline ::std::string* release_usr_from();
  inline void set_allocated_usr_from(::std::string* usr_from);

  // optional string msg_cont = 5;
  inline bool has_msg_cont() const;
  inline void clear_msg_cont();
  static const int kMsgContFieldNumber = 5;
  inline const ::std::string& msg_cont() const;
  inline void set_msg_cont(const ::std::string& value);
  inline void set_msg_cont(const char* value);
  inline void set_msg_cont(const char* value, size_t size);
  inline ::std::string* mutable_msg_cont();
  inline ::std::string* release_msg_cont();
  inline void set_allocated_msg_cont(::std::string* msg_cont);

  // optional string rom_id = 6;
  inline bool has_rom_id() const;
  inline void clear_rom_id();
  static const int kRomIdFieldNumber = 6;
  inline const ::std::string& rom_id() const;
  inline void set_rom_id(const ::std::string& value);
  inline void set_rom_id(const char* value);
  inline void set_rom_id(const char* value, size_t size);
  inline ::std::string* mutable_rom_id();
  inline ::std::string* release_rom_id();
  inline void set_allocated_rom_id(::std::string* rom_id);

  // optional string rom_name = 7;
  inline bool has_rom_name() const;
  inline void clear_rom_name();
  static const int kRomNameFieldNumber = 7;
  inline const ::std::string& rom_name() const;
  inline void set_rom_name(const ::std::string& value);
  inline void set_rom_name(const char* value);
  inline void set_rom_name(const char* value, size_t size);
  inline ::std::string* mutable_rom_name();
  inline ::std::string* release_rom_name();
  inline void set_allocated_rom_name(::std::string* rom_name);

  // optional string nck_name = 8;
  inline bool has_nck_name() const;
  inline void clear_nck_name();
  static const int kNckNameFieldNumber = 8;
  inline const ::std::string& nck_name() const;
  inline void set_nck_name(const ::std::string& value);
  inline void set_nck_name(const char* value);
  inline void set_nck_name(const char* value, size_t size);
  inline ::std::string* mutable_nck_name();
  inline ::std::string* release_nck_name();
  inline void set_allocated_nck_name(::std::string* nck_name);

  // optional string usr_token = 9;
  inline bool has_usr_token() const;
  inline void clear_usr_token();
  static const int kUsrTokenFieldNumber = 9;
  inline const ::std::string& usr_token() const;
  inline void set_usr_token(const ::std::string& value);
  inline void set_usr_token(const char* value);
  inline void set_usr_token(const char* value, size_t size);
  inline ::std::string* mutable_usr_token();
  inline ::std::string* release_usr_token();
  inline void set_allocated_usr_token(::std::string* usr_token);

  // optional sint64 msg_seqs = 10;
  inline bool has_msg_seqs() const;
  inline void clear_msg_seqs();
  static const int kMsgSeqsFieldNumber = 10;
  inline ::google::protobuf::int64 msg_seqs() const;
  inline void set_msg_seqs(::google::protobuf::int64 value);

  // optional sint32 mem_num = 11;
  inline bool has_mem_num() const;
  inline void clear_mem_num();
  static const int kMemNumFieldNumber = 11;
  inline ::google::protobuf::int32 mem_num() const;
  inline void set_mem_num(::google::protobuf::int32 value);

  // optional .pms.ToUser usr_toto = 12;
  inline bool has_usr_toto() const;
  inline void clear_usr_toto();
  static const int kUsrTotoFieldNumber = 12;
  inline const ::pms::ToUser& usr_toto() const;
  inline ::pms::ToUser* mutable_usr_toto();
  inline ::pms::ToUser* release_usr_toto();
  inline void set_allocated_usr_toto(::pms::ToUser* usr_toto);

  // @@protoc_insertion_point(class_scope:pms.MeetMsg)
 private:
  inline void set_has_msg_head();
  inline void clear_has_msg_head();
  inline void set_has_msg_tag();
  inline void clear_has_msg_tag();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_usr_from();
  inline void clear_has_usr_from();
  inline void set_has_msg_cont();
  inline void clear_has_msg_cont();
  inline void set_has_rom_id();
  inline void clear_has_rom_id();
  inline void set_has_rom_name();
  inline void clear_has_rom_name();
  inline void set_has_nck_name();
  inline void clear_has_nck_name();
  inline void set_has_usr_token();
  inline void clear_has_usr_token();
  inline void set_has_msg_seqs();
  inline void clear_has_msg_seqs();
  inline void set_has_mem_num();
  inline void clear_has_mem_num();
  inline void set_has_usr_toto();
  inline void clear_has_usr_toto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int msg_head_;
  int msg_tag_;
  ::std::string* usr_from_;
  ::std::string* msg_cont_;
  ::std::string* rom_id_;
  ::std::string* rom_name_;
  int msg_type_;
  ::google::protobuf::int32 mem_num_;
  ::std::string* nck_name_;
  ::std::string* usr_token_;
  ::google::protobuf::int64 msg_seqs_;
  ::pms::ToUser* usr_toto_;
  friend void  protobuf_AddDesc_meet_5fmsg_2eproto();
  friend void protobuf_AssignDesc_meet_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_meet_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static MeetMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// Login

// optional string usr_from = 1;
inline bool Login::has_usr_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_usr_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_usr_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_usr_from() {
  if (usr_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_->clear();
  }
  clear_has_usr_from();
}
inline const ::std::string& Login::usr_from() const {
  // @@protoc_insertion_point(field_get:pms.Login.usr_from)
  return *usr_from_;
}
inline void Login::set_usr_from(const ::std::string& value) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(value);
  // @@protoc_insertion_point(field_set:pms.Login.usr_from)
}
inline void Login::set_usr_from(const char* value) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.Login.usr_from)
}
inline void Login::set_usr_from(const char* value, size_t size) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.Login.usr_from)
}
inline ::std::string* Login::mutable_usr_from() {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.Login.usr_from)
  return usr_from_;
}
inline ::std::string* Login::release_usr_from() {
  clear_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usr_from_;
    usr_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login::set_allocated_usr_from(::std::string* usr_from) {
  if (usr_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usr_from_;
  }
  if (usr_from) {
    set_has_usr_from();
    usr_from_ = usr_from;
  } else {
    clear_has_usr_from();
    usr_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.Login.usr_from)
}

// optional string usr_token = 2;
inline bool Login::has_usr_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_usr_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_usr_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_usr_token() {
  if (usr_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_->clear();
  }
  clear_has_usr_token();
}
inline const ::std::string& Login::usr_token() const {
  // @@protoc_insertion_point(field_get:pms.Login.usr_token)
  return *usr_token_;
}
inline void Login::set_usr_token(const ::std::string& value) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(value);
  // @@protoc_insertion_point(field_set:pms.Login.usr_token)
}
inline void Login::set_usr_token(const char* value) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.Login.usr_token)
}
inline void Login::set_usr_token(const char* value, size_t size) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.Login.usr_token)
}
inline ::std::string* Login::mutable_usr_token() {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.Login.usr_token)
  return usr_token_;
}
inline ::std::string* Login::release_usr_token() {
  clear_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usr_token_;
    usr_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login::set_allocated_usr_token(::std::string* usr_token) {
  if (usr_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usr_token_;
  }
  if (usr_token) {
    set_has_usr_token();
    usr_token_ = usr_token;
  } else {
    clear_has_usr_token();
    usr_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.Login.usr_token)
}

// optional string usr_nname = 3;
inline bool Login::has_usr_nname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login::set_has_usr_nname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login::clear_has_usr_nname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login::clear_usr_nname() {
  if (usr_nname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_nname_->clear();
  }
  clear_has_usr_nname();
}
inline const ::std::string& Login::usr_nname() const {
  // @@protoc_insertion_point(field_get:pms.Login.usr_nname)
  return *usr_nname_;
}
inline void Login::set_usr_nname(const ::std::string& value) {
  set_has_usr_nname();
  if (usr_nname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_nname_ = new ::std::string;
  }
  usr_nname_->assign(value);
  // @@protoc_insertion_point(field_set:pms.Login.usr_nname)
}
inline void Login::set_usr_nname(const char* value) {
  set_has_usr_nname();
  if (usr_nname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_nname_ = new ::std::string;
  }
  usr_nname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.Login.usr_nname)
}
inline void Login::set_usr_nname(const char* value, size_t size) {
  set_has_usr_nname();
  if (usr_nname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_nname_ = new ::std::string;
  }
  usr_nname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.Login.usr_nname)
}
inline ::std::string* Login::mutable_usr_nname() {
  set_has_usr_nname();
  if (usr_nname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_nname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.Login.usr_nname)
  return usr_nname_;
}
inline ::std::string* Login::release_usr_nname() {
  clear_has_usr_nname();
  if (usr_nname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usr_nname_;
    usr_nname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login::set_allocated_usr_nname(::std::string* usr_nname) {
  if (usr_nname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usr_nname_;
  }
  if (usr_nname) {
    set_has_usr_nname();
    usr_nname_ = usr_nname;
  } else {
    clear_has_usr_nname();
    usr_nname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.Login.usr_nname)
}

// -------------------------------------------------------------------

// Logout

// optional string usr_from = 1;
inline bool Logout::has_usr_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Logout::set_has_usr_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Logout::clear_has_usr_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Logout::clear_usr_from() {
  if (usr_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_->clear();
  }
  clear_has_usr_from();
}
inline const ::std::string& Logout::usr_from() const {
  // @@protoc_insertion_point(field_get:pms.Logout.usr_from)
  return *usr_from_;
}
inline void Logout::set_usr_from(const ::std::string& value) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(value);
  // @@protoc_insertion_point(field_set:pms.Logout.usr_from)
}
inline void Logout::set_usr_from(const char* value) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.Logout.usr_from)
}
inline void Logout::set_usr_from(const char* value, size_t size) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.Logout.usr_from)
}
inline ::std::string* Logout::mutable_usr_from() {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.Logout.usr_from)
  return usr_from_;
}
inline ::std::string* Logout::release_usr_from() {
  clear_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usr_from_;
    usr_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Logout::set_allocated_usr_from(::std::string* usr_from) {
  if (usr_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usr_from_;
  }
  if (usr_from) {
    set_has_usr_from();
    usr_from_ = usr_from;
  } else {
    clear_has_usr_from();
    usr_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.Logout.usr_from)
}

// optional string usr_token = 2;
inline bool Logout::has_usr_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Logout::set_has_usr_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Logout::clear_has_usr_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Logout::clear_usr_token() {
  if (usr_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_->clear();
  }
  clear_has_usr_token();
}
inline const ::std::string& Logout::usr_token() const {
  // @@protoc_insertion_point(field_get:pms.Logout.usr_token)
  return *usr_token_;
}
inline void Logout::set_usr_token(const ::std::string& value) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(value);
  // @@protoc_insertion_point(field_set:pms.Logout.usr_token)
}
inline void Logout::set_usr_token(const char* value) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.Logout.usr_token)
}
inline void Logout::set_usr_token(const char* value, size_t size) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.Logout.usr_token)
}
inline ::std::string* Logout::mutable_usr_token() {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.Logout.usr_token)
  return usr_token_;
}
inline ::std::string* Logout::release_usr_token() {
  clear_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usr_token_;
    usr_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Logout::set_allocated_usr_token(::std::string* usr_token) {
  if (usr_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usr_token_;
  }
  if (usr_token) {
    set_has_usr_token();
    usr_token_ = usr_token;
  } else {
    clear_has_usr_token();
    usr_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.Logout.usr_token)
}

// -------------------------------------------------------------------

// Keep

// optional string usr_from = 1;
inline bool Keep::has_usr_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Keep::set_has_usr_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Keep::clear_has_usr_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Keep::clear_usr_from() {
  if (usr_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_->clear();
  }
  clear_has_usr_from();
}
inline const ::std::string& Keep::usr_from() const {
  // @@protoc_insertion_point(field_get:pms.Keep.usr_from)
  return *usr_from_;
}
inline void Keep::set_usr_from(const ::std::string& value) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(value);
  // @@protoc_insertion_point(field_set:pms.Keep.usr_from)
}
inline void Keep::set_usr_from(const char* value) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.Keep.usr_from)
}
inline void Keep::set_usr_from(const char* value, size_t size) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.Keep.usr_from)
}
inline ::std::string* Keep::mutable_usr_from() {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.Keep.usr_from)
  return usr_from_;
}
inline ::std::string* Keep::release_usr_from() {
  clear_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usr_from_;
    usr_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Keep::set_allocated_usr_from(::std::string* usr_from) {
  if (usr_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usr_from_;
  }
  if (usr_from) {
    set_has_usr_from();
    usr_from_ = usr_from;
  } else {
    clear_has_usr_from();
    usr_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.Keep.usr_from)
}

// -------------------------------------------------------------------

// MeetMsg

// optional .pms.EMsgHead msg_head = 1 [default = HSND];
inline bool MeetMsg::has_msg_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeetMsg::set_has_msg_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeetMsg::clear_has_msg_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeetMsg::clear_msg_head() {
  msg_head_ = 1;
  clear_has_msg_head();
}
inline ::pms::EMsgHead MeetMsg::msg_head() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.msg_head)
  return static_cast< ::pms::EMsgHead >(msg_head_);
}
inline void MeetMsg::set_msg_head(::pms::EMsgHead value) {
  assert(::pms::EMsgHead_IsValid(value));
  set_has_msg_head();
  msg_head_ = value;
  // @@protoc_insertion_point(field_set:pms.MeetMsg.msg_head)
}

// optional .pms.EMsgTag msg_tag = 2 [default = TCHAT];
inline bool MeetMsg::has_msg_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeetMsg::set_has_msg_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeetMsg::clear_has_msg_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeetMsg::clear_msg_tag() {
  msg_tag_ = 3;
  clear_has_msg_tag();
}
inline ::pms::EMsgTag MeetMsg::msg_tag() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.msg_tag)
  return static_cast< ::pms::EMsgTag >(msg_tag_);
}
inline void MeetMsg::set_msg_tag(::pms::EMsgTag value) {
  assert(::pms::EMsgTag_IsValid(value));
  set_has_msg_tag();
  msg_tag_ = value;
  // @@protoc_insertion_point(field_set:pms.MeetMsg.msg_tag)
}

// optional .pms.EMsgType msg_type = 3 [default = TMSG];
inline bool MeetMsg::has_msg_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MeetMsg::set_has_msg_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MeetMsg::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MeetMsg::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::pms::EMsgType MeetMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.msg_type)
  return static_cast< ::pms::EMsgType >(msg_type_);
}
inline void MeetMsg::set_msg_type(::pms::EMsgType value) {
  assert(::pms::EMsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:pms.MeetMsg.msg_type)
}

// optional string usr_from = 4;
inline bool MeetMsg::has_usr_from() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MeetMsg::set_has_usr_from() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MeetMsg::clear_has_usr_from() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MeetMsg::clear_usr_from() {
  if (usr_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_->clear();
  }
  clear_has_usr_from();
}
inline const ::std::string& MeetMsg::usr_from() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.usr_from)
  return *usr_from_;
}
inline void MeetMsg::set_usr_from(const ::std::string& value) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(value);
  // @@protoc_insertion_point(field_set:pms.MeetMsg.usr_from)
}
inline void MeetMsg::set_usr_from(const char* value) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.MeetMsg.usr_from)
}
inline void MeetMsg::set_usr_from(const char* value, size_t size) {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  usr_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.MeetMsg.usr_from)
}
inline ::std::string* MeetMsg::mutable_usr_from() {
  set_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.MeetMsg.usr_from)
  return usr_from_;
}
inline ::std::string* MeetMsg::release_usr_from() {
  clear_has_usr_from();
  if (usr_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usr_from_;
    usr_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MeetMsg::set_allocated_usr_from(::std::string* usr_from) {
  if (usr_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usr_from_;
  }
  if (usr_from) {
    set_has_usr_from();
    usr_from_ = usr_from;
  } else {
    clear_has_usr_from();
    usr_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.MeetMsg.usr_from)
}

// optional string msg_cont = 5;
inline bool MeetMsg::has_msg_cont() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MeetMsg::set_has_msg_cont() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MeetMsg::clear_has_msg_cont() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MeetMsg::clear_msg_cont() {
  if (msg_cont_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_cont_->clear();
  }
  clear_has_msg_cont();
}
inline const ::std::string& MeetMsg::msg_cont() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.msg_cont)
  return *msg_cont_;
}
inline void MeetMsg::set_msg_cont(const ::std::string& value) {
  set_has_msg_cont();
  if (msg_cont_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_cont_ = new ::std::string;
  }
  msg_cont_->assign(value);
  // @@protoc_insertion_point(field_set:pms.MeetMsg.msg_cont)
}
inline void MeetMsg::set_msg_cont(const char* value) {
  set_has_msg_cont();
  if (msg_cont_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_cont_ = new ::std::string;
  }
  msg_cont_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.MeetMsg.msg_cont)
}
inline void MeetMsg::set_msg_cont(const char* value, size_t size) {
  set_has_msg_cont();
  if (msg_cont_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_cont_ = new ::std::string;
  }
  msg_cont_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.MeetMsg.msg_cont)
}
inline ::std::string* MeetMsg::mutable_msg_cont() {
  set_has_msg_cont();
  if (msg_cont_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_cont_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.MeetMsg.msg_cont)
  return msg_cont_;
}
inline ::std::string* MeetMsg::release_msg_cont() {
  clear_has_msg_cont();
  if (msg_cont_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_cont_;
    msg_cont_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MeetMsg::set_allocated_msg_cont(::std::string* msg_cont) {
  if (msg_cont_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_cont_;
  }
  if (msg_cont) {
    set_has_msg_cont();
    msg_cont_ = msg_cont;
  } else {
    clear_has_msg_cont();
    msg_cont_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.MeetMsg.msg_cont)
}

// optional string rom_id = 6;
inline bool MeetMsg::has_rom_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MeetMsg::set_has_rom_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MeetMsg::clear_has_rom_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MeetMsg::clear_rom_id() {
  if (rom_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_id_->clear();
  }
  clear_has_rom_id();
}
inline const ::std::string& MeetMsg::rom_id() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.rom_id)
  return *rom_id_;
}
inline void MeetMsg::set_rom_id(const ::std::string& value) {
  set_has_rom_id();
  if (rom_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_id_ = new ::std::string;
  }
  rom_id_->assign(value);
  // @@protoc_insertion_point(field_set:pms.MeetMsg.rom_id)
}
inline void MeetMsg::set_rom_id(const char* value) {
  set_has_rom_id();
  if (rom_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_id_ = new ::std::string;
  }
  rom_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.MeetMsg.rom_id)
}
inline void MeetMsg::set_rom_id(const char* value, size_t size) {
  set_has_rom_id();
  if (rom_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_id_ = new ::std::string;
  }
  rom_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.MeetMsg.rom_id)
}
inline ::std::string* MeetMsg::mutable_rom_id() {
  set_has_rom_id();
  if (rom_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.MeetMsg.rom_id)
  return rom_id_;
}
inline ::std::string* MeetMsg::release_rom_id() {
  clear_has_rom_id();
  if (rom_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rom_id_;
    rom_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MeetMsg::set_allocated_rom_id(::std::string* rom_id) {
  if (rom_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rom_id_;
  }
  if (rom_id) {
    set_has_rom_id();
    rom_id_ = rom_id;
  } else {
    clear_has_rom_id();
    rom_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.MeetMsg.rom_id)
}

// optional string rom_name = 7;
inline bool MeetMsg::has_rom_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MeetMsg::set_has_rom_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MeetMsg::clear_has_rom_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MeetMsg::clear_rom_name() {
  if (rom_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_name_->clear();
  }
  clear_has_rom_name();
}
inline const ::std::string& MeetMsg::rom_name() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.rom_name)
  return *rom_name_;
}
inline void MeetMsg::set_rom_name(const ::std::string& value) {
  set_has_rom_name();
  if (rom_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_name_ = new ::std::string;
  }
  rom_name_->assign(value);
  // @@protoc_insertion_point(field_set:pms.MeetMsg.rom_name)
}
inline void MeetMsg::set_rom_name(const char* value) {
  set_has_rom_name();
  if (rom_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_name_ = new ::std::string;
  }
  rom_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.MeetMsg.rom_name)
}
inline void MeetMsg::set_rom_name(const char* value, size_t size) {
  set_has_rom_name();
  if (rom_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_name_ = new ::std::string;
  }
  rom_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.MeetMsg.rom_name)
}
inline ::std::string* MeetMsg::mutable_rom_name() {
  set_has_rom_name();
  if (rom_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rom_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.MeetMsg.rom_name)
  return rom_name_;
}
inline ::std::string* MeetMsg::release_rom_name() {
  clear_has_rom_name();
  if (rom_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rom_name_;
    rom_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MeetMsg::set_allocated_rom_name(::std::string* rom_name) {
  if (rom_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rom_name_;
  }
  if (rom_name) {
    set_has_rom_name();
    rom_name_ = rom_name;
  } else {
    clear_has_rom_name();
    rom_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.MeetMsg.rom_name)
}

// optional string nck_name = 8;
inline bool MeetMsg::has_nck_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MeetMsg::set_has_nck_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MeetMsg::clear_has_nck_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MeetMsg::clear_nck_name() {
  if (nck_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nck_name_->clear();
  }
  clear_has_nck_name();
}
inline const ::std::string& MeetMsg::nck_name() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.nck_name)
  return *nck_name_;
}
inline void MeetMsg::set_nck_name(const ::std::string& value) {
  set_has_nck_name();
  if (nck_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nck_name_ = new ::std::string;
  }
  nck_name_->assign(value);
  // @@protoc_insertion_point(field_set:pms.MeetMsg.nck_name)
}
inline void MeetMsg::set_nck_name(const char* value) {
  set_has_nck_name();
  if (nck_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nck_name_ = new ::std::string;
  }
  nck_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.MeetMsg.nck_name)
}
inline void MeetMsg::set_nck_name(const char* value, size_t size) {
  set_has_nck_name();
  if (nck_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nck_name_ = new ::std::string;
  }
  nck_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.MeetMsg.nck_name)
}
inline ::std::string* MeetMsg::mutable_nck_name() {
  set_has_nck_name();
  if (nck_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nck_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.MeetMsg.nck_name)
  return nck_name_;
}
inline ::std::string* MeetMsg::release_nck_name() {
  clear_has_nck_name();
  if (nck_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nck_name_;
    nck_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MeetMsg::set_allocated_nck_name(::std::string* nck_name) {
  if (nck_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nck_name_;
  }
  if (nck_name) {
    set_has_nck_name();
    nck_name_ = nck_name;
  } else {
    clear_has_nck_name();
    nck_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.MeetMsg.nck_name)
}

// optional string usr_token = 9;
inline bool MeetMsg::has_usr_token() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MeetMsg::set_has_usr_token() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MeetMsg::clear_has_usr_token() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MeetMsg::clear_usr_token() {
  if (usr_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_->clear();
  }
  clear_has_usr_token();
}
inline const ::std::string& MeetMsg::usr_token() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.usr_token)
  return *usr_token_;
}
inline void MeetMsg::set_usr_token(const ::std::string& value) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(value);
  // @@protoc_insertion_point(field_set:pms.MeetMsg.usr_token)
}
inline void MeetMsg::set_usr_token(const char* value) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.MeetMsg.usr_token)
}
inline void MeetMsg::set_usr_token(const char* value, size_t size) {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  usr_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.MeetMsg.usr_token)
}
inline ::std::string* MeetMsg::mutable_usr_token() {
  set_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usr_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.MeetMsg.usr_token)
  return usr_token_;
}
inline ::std::string* MeetMsg::release_usr_token() {
  clear_has_usr_token();
  if (usr_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usr_token_;
    usr_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MeetMsg::set_allocated_usr_token(::std::string* usr_token) {
  if (usr_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usr_token_;
  }
  if (usr_token) {
    set_has_usr_token();
    usr_token_ = usr_token;
  } else {
    clear_has_usr_token();
    usr_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.MeetMsg.usr_token)
}

// optional sint64 msg_seqs = 10;
inline bool MeetMsg::has_msg_seqs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MeetMsg::set_has_msg_seqs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MeetMsg::clear_has_msg_seqs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MeetMsg::clear_msg_seqs() {
  msg_seqs_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seqs();
}
inline ::google::protobuf::int64 MeetMsg::msg_seqs() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.msg_seqs)
  return msg_seqs_;
}
inline void MeetMsg::set_msg_seqs(::google::protobuf::int64 value) {
  set_has_msg_seqs();
  msg_seqs_ = value;
  // @@protoc_insertion_point(field_set:pms.MeetMsg.msg_seqs)
}

// optional sint32 mem_num = 11;
inline bool MeetMsg::has_mem_num() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MeetMsg::set_has_mem_num() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MeetMsg::clear_has_mem_num() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MeetMsg::clear_mem_num() {
  mem_num_ = 0;
  clear_has_mem_num();
}
inline ::google::protobuf::int32 MeetMsg::mem_num() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.mem_num)
  return mem_num_;
}
inline void MeetMsg::set_mem_num(::google::protobuf::int32 value) {
  set_has_mem_num();
  mem_num_ = value;
  // @@protoc_insertion_point(field_set:pms.MeetMsg.mem_num)
}

// optional .pms.ToUser usr_toto = 12;
inline bool MeetMsg::has_usr_toto() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MeetMsg::set_has_usr_toto() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MeetMsg::clear_has_usr_toto() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MeetMsg::clear_usr_toto() {
  if (usr_toto_ != NULL) usr_toto_->::pms::ToUser::Clear();
  clear_has_usr_toto();
}
inline const ::pms::ToUser& MeetMsg::usr_toto() const {
  // @@protoc_insertion_point(field_get:pms.MeetMsg.usr_toto)
  return usr_toto_ != NULL ? *usr_toto_ : *default_instance_->usr_toto_;
}
inline ::pms::ToUser* MeetMsg::mutable_usr_toto() {
  set_has_usr_toto();
  if (usr_toto_ == NULL) usr_toto_ = new ::pms::ToUser;
  // @@protoc_insertion_point(field_mutable:pms.MeetMsg.usr_toto)
  return usr_toto_;
}
inline ::pms::ToUser* MeetMsg::release_usr_toto() {
  clear_has_usr_toto();
  ::pms::ToUser* temp = usr_toto_;
  usr_toto_ = NULL;
  return temp;
}
inline void MeetMsg::set_allocated_usr_toto(::pms::ToUser* usr_toto) {
  delete usr_toto_;
  usr_toto_ = usr_toto;
  if (usr_toto) {
    set_has_usr_toto();
  } else {
    clear_has_usr_toto();
  }
  // @@protoc_insertion_point(field_set_allocated:pms.MeetMsg.usr_toto)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pms

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_meet_5fmsg_2eproto__INCLUDED
