// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sys_msg.proto

#ifndef PROTOBUF_sys_5fmsg_2eproto__INCLUDED
#define PROTOBUF_sys_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common_msg.pb.h"
#include "sys_msg_type.pb.h"
// @@protoc_insertion_point(includes)

namespace pms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_sys_5fmsg_2eproto();
void protobuf_AssignDesc_sys_5fmsg_2eproto();
void protobuf_ShutdownFile_sys_5fmsg_2eproto();

class ConnMsg;
class RelayMsg;
class TransferMsg;

// ===================================================================

class ConnMsg : public ::google::protobuf::Message {
 public:
  ConnMsg();
  virtual ~ConnMsg();

  ConnMsg(const ConnMsg& from);

  inline ConnMsg& operator=(const ConnMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnMsg& default_instance();

  void Swap(ConnMsg* other);

  // implements Message ----------------------------------------------

  ConnMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnMsg& from);
  void MergeFrom(const ConnMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pms.EConnTag conn_tag = 1;
  inline bool has_conn_tag() const;
  inline void clear_conn_tag();
  static const int kConnTagFieldNumber = 1;
  inline ::pms::EConnTag conn_tag() const;
  inline void set_conn_tag(::pms::EConnTag value);

  // optional .pms.ETransferModule tr_module = 2;
  inline bool has_tr_module() const;
  inline void clear_tr_module();
  static const int kTrModuleFieldNumber = 2;
  inline ::pms::ETransferModule tr_module() const;
  inline void set_tr_module(::pms::ETransferModule value);

  // optional string moduleid = 3;
  inline bool has_moduleid() const;
  inline void clear_moduleid();
  static const int kModuleidFieldNumber = 3;
  inline const ::std::string& moduleid() const;
  inline void set_moduleid(const ::std::string& value);
  inline void set_moduleid(const char* value);
  inline void set_moduleid(const char* value, size_t size);
  inline ::std::string* mutable_moduleid();
  inline ::std::string* release_moduleid();
  inline void set_allocated_moduleid(::std::string* moduleid);

  // optional string transferid = 4;
  inline bool has_transferid() const;
  inline void clear_transferid();
  static const int kTransferidFieldNumber = 4;
  inline const ::std::string& transferid() const;
  inline void set_transferid(const ::std::string& value);
  inline void set_transferid(const char* value);
  inline void set_transferid(const char* value, size_t size);
  inline ::std::string* mutable_transferid();
  inline ::std::string* release_transferid();
  inline void set_allocated_transferid(::std::string* transferid);

  // @@protoc_insertion_point(class_scope:pms.ConnMsg)
 private:
  inline void set_has_conn_tag();
  inline void clear_has_conn_tag();
  inline void set_has_tr_module();
  inline void clear_has_tr_module();
  inline void set_has_moduleid();
  inline void clear_has_moduleid();
  inline void set_has_transferid();
  inline void clear_has_transferid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int conn_tag_;
  int tr_module_;
  ::std::string* moduleid_;
  ::std::string* transferid_;
  friend void  protobuf_AddDesc_sys_5fmsg_2eproto();
  friend void protobuf_AssignDesc_sys_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_sys_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static ConnMsg* default_instance_;
};
// -------------------------------------------------------------------

class RelayMsg : public ::google::protobuf::Message {
 public:
  RelayMsg();
  virtual ~RelayMsg();

  RelayMsg(const RelayMsg& from);

  inline RelayMsg& operator=(const RelayMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelayMsg& default_instance();

  void Swap(RelayMsg* other);

  // implements Message ----------------------------------------------

  RelayMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RelayMsg& from);
  void MergeFrom(const RelayMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pms.EServerCmd svr_cmds = 1;
  inline bool has_svr_cmds() const;
  inline void clear_svr_cmds();
  static const int kSvrCmdsFieldNumber = 1;
  inline ::pms::EServerCmd svr_cmds() const;
  inline void set_svr_cmds(::pms::EServerCmd value);

  // optional .pms.ETransferModule tr_module = 2;
  inline bool has_tr_module() const;
  inline void clear_tr_module();
  static const int kTrModuleFieldNumber = 2;
  inline ::pms::ETransferModule tr_module() const;
  inline void set_tr_module(::pms::ETransferModule value);

  // optional string connector = 3;
  inline bool has_connector() const;
  inline void clear_connector();
  static const int kConnectorFieldNumber = 3;
  inline const ::std::string& connector() const;
  inline void set_connector(const ::std::string& value);
  inline void set_connector(const char* value);
  inline void set_connector(const char* value, size_t size);
  inline ::std::string* mutable_connector();
  inline ::std::string* release_connector();
  inline void set_allocated_connector(::std::string* connector);

  // optional bytes content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional .pms.ToUser touser = 5;
  inline bool has_touser() const;
  inline void clear_touser();
  static const int kTouserFieldNumber = 5;
  inline const ::pms::ToUser& touser() const;
  inline ::pms::ToUser* mutable_touser();
  inline ::pms::ToUser* release_touser();
  inline void set_allocated_touser(::pms::ToUser* touser);

  // @@protoc_insertion_point(class_scope:pms.RelayMsg)
 private:
  inline void set_has_svr_cmds();
  inline void clear_has_svr_cmds();
  inline void set_has_tr_module();
  inline void clear_has_tr_module();
  inline void set_has_connector();
  inline void clear_has_connector();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_touser();
  inline void clear_has_touser();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int svr_cmds_;
  int tr_module_;
  ::std::string* connector_;
  ::std::string* content_;
  ::pms::ToUser* touser_;
  friend void  protobuf_AddDesc_sys_5fmsg_2eproto();
  friend void protobuf_AssignDesc_sys_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_sys_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static RelayMsg* default_instance_;
};
// -------------------------------------------------------------------

class TransferMsg : public ::google::protobuf::Message {
 public:
  TransferMsg();
  virtual ~TransferMsg();

  TransferMsg(const TransferMsg& from);

  inline TransferMsg& operator=(const TransferMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferMsg& default_instance();

  void Swap(TransferMsg* other);

  // implements Message ----------------------------------------------

  TransferMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferMsg& from);
  void MergeFrom(const TransferMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pms.ETransferType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pms::ETransferType type() const;
  inline void set_type(::pms::ETransferType value);

  // optional .pms.ETransferFlag flag = 2 [default = FNOACK];
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::pms::ETransferFlag flag() const;
  inline void set_flag(::pms::ETransferFlag value);

  // optional .pms.ETransferPriority priority = 3 [default = PNORMAL];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::pms::ETransferPriority priority() const;
  inline void set_priority(::pms::ETransferPriority value);

  // optional bytes content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:pms.TransferMsg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  int flag_;
  ::std::string* content_;
  int priority_;
  friend void  protobuf_AddDesc_sys_5fmsg_2eproto();
  friend void protobuf_AssignDesc_sys_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_sys_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static TransferMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// ConnMsg

// optional .pms.EConnTag conn_tag = 1;
inline bool ConnMsg::has_conn_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnMsg::set_has_conn_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnMsg::clear_has_conn_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnMsg::clear_conn_tag() {
  conn_tag_ = 1;
  clear_has_conn_tag();
}
inline ::pms::EConnTag ConnMsg::conn_tag() const {
  // @@protoc_insertion_point(field_get:pms.ConnMsg.conn_tag)
  return static_cast< ::pms::EConnTag >(conn_tag_);
}
inline void ConnMsg::set_conn_tag(::pms::EConnTag value) {
  assert(::pms::EConnTag_IsValid(value));
  set_has_conn_tag();
  conn_tag_ = value;
  // @@protoc_insertion_point(field_set:pms.ConnMsg.conn_tag)
}

// optional .pms.ETransferModule tr_module = 2;
inline bool ConnMsg::has_tr_module() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnMsg::set_has_tr_module() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnMsg::clear_has_tr_module() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnMsg::clear_tr_module() {
  tr_module_ = 1;
  clear_has_tr_module();
}
inline ::pms::ETransferModule ConnMsg::tr_module() const {
  // @@protoc_insertion_point(field_get:pms.ConnMsg.tr_module)
  return static_cast< ::pms::ETransferModule >(tr_module_);
}
inline void ConnMsg::set_tr_module(::pms::ETransferModule value) {
  assert(::pms::ETransferModule_IsValid(value));
  set_has_tr_module();
  tr_module_ = value;
  // @@protoc_insertion_point(field_set:pms.ConnMsg.tr_module)
}

// optional string moduleid = 3;
inline bool ConnMsg::has_moduleid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnMsg::set_has_moduleid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnMsg::clear_has_moduleid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnMsg::clear_moduleid() {
  if (moduleid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moduleid_->clear();
  }
  clear_has_moduleid();
}
inline const ::std::string& ConnMsg::moduleid() const {
  // @@protoc_insertion_point(field_get:pms.ConnMsg.moduleid)
  return *moduleid_;
}
inline void ConnMsg::set_moduleid(const ::std::string& value) {
  set_has_moduleid();
  if (moduleid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moduleid_ = new ::std::string;
  }
  moduleid_->assign(value);
  // @@protoc_insertion_point(field_set:pms.ConnMsg.moduleid)
}
inline void ConnMsg::set_moduleid(const char* value) {
  set_has_moduleid();
  if (moduleid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moduleid_ = new ::std::string;
  }
  moduleid_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.ConnMsg.moduleid)
}
inline void ConnMsg::set_moduleid(const char* value, size_t size) {
  set_has_moduleid();
  if (moduleid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moduleid_ = new ::std::string;
  }
  moduleid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.ConnMsg.moduleid)
}
inline ::std::string* ConnMsg::mutable_moduleid() {
  set_has_moduleid();
  if (moduleid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    moduleid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.ConnMsg.moduleid)
  return moduleid_;
}
inline ::std::string* ConnMsg::release_moduleid() {
  clear_has_moduleid();
  if (moduleid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = moduleid_;
    moduleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnMsg::set_allocated_moduleid(::std::string* moduleid) {
  if (moduleid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete moduleid_;
  }
  if (moduleid) {
    set_has_moduleid();
    moduleid_ = moduleid;
  } else {
    clear_has_moduleid();
    moduleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.ConnMsg.moduleid)
}

// optional string transferid = 4;
inline bool ConnMsg::has_transferid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnMsg::set_has_transferid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnMsg::clear_has_transferid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnMsg::clear_transferid() {
  if (transferid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferid_->clear();
  }
  clear_has_transferid();
}
inline const ::std::string& ConnMsg::transferid() const {
  // @@protoc_insertion_point(field_get:pms.ConnMsg.transferid)
  return *transferid_;
}
inline void ConnMsg::set_transferid(const ::std::string& value) {
  set_has_transferid();
  if (transferid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferid_ = new ::std::string;
  }
  transferid_->assign(value);
  // @@protoc_insertion_point(field_set:pms.ConnMsg.transferid)
}
inline void ConnMsg::set_transferid(const char* value) {
  set_has_transferid();
  if (transferid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferid_ = new ::std::string;
  }
  transferid_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.ConnMsg.transferid)
}
inline void ConnMsg::set_transferid(const char* value, size_t size) {
  set_has_transferid();
  if (transferid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferid_ = new ::std::string;
  }
  transferid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.ConnMsg.transferid)
}
inline ::std::string* ConnMsg::mutable_transferid() {
  set_has_transferid();
  if (transferid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.ConnMsg.transferid)
  return transferid_;
}
inline ::std::string* ConnMsg::release_transferid() {
  clear_has_transferid();
  if (transferid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferid_;
    transferid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnMsg::set_allocated_transferid(::std::string* transferid) {
  if (transferid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferid_;
  }
  if (transferid) {
    set_has_transferid();
    transferid_ = transferid;
  } else {
    clear_has_transferid();
    transferid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.ConnMsg.transferid)
}

// -------------------------------------------------------------------

// RelayMsg

// optional .pms.EServerCmd svr_cmds = 1;
inline bool RelayMsg::has_svr_cmds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelayMsg::set_has_svr_cmds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelayMsg::clear_has_svr_cmds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelayMsg::clear_svr_cmds() {
  svr_cmds_ = 1;
  clear_has_svr_cmds();
}
inline ::pms::EServerCmd RelayMsg::svr_cmds() const {
  // @@protoc_insertion_point(field_get:pms.RelayMsg.svr_cmds)
  return static_cast< ::pms::EServerCmd >(svr_cmds_);
}
inline void RelayMsg::set_svr_cmds(::pms::EServerCmd value) {
  assert(::pms::EServerCmd_IsValid(value));
  set_has_svr_cmds();
  svr_cmds_ = value;
  // @@protoc_insertion_point(field_set:pms.RelayMsg.svr_cmds)
}

// optional .pms.ETransferModule tr_module = 2;
inline bool RelayMsg::has_tr_module() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelayMsg::set_has_tr_module() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelayMsg::clear_has_tr_module() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelayMsg::clear_tr_module() {
  tr_module_ = 1;
  clear_has_tr_module();
}
inline ::pms::ETransferModule RelayMsg::tr_module() const {
  // @@protoc_insertion_point(field_get:pms.RelayMsg.tr_module)
  return static_cast< ::pms::ETransferModule >(tr_module_);
}
inline void RelayMsg::set_tr_module(::pms::ETransferModule value) {
  assert(::pms::ETransferModule_IsValid(value));
  set_has_tr_module();
  tr_module_ = value;
  // @@protoc_insertion_point(field_set:pms.RelayMsg.tr_module)
}

// optional string connector = 3;
inline bool RelayMsg::has_connector() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelayMsg::set_has_connector() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelayMsg::clear_has_connector() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelayMsg::clear_connector() {
  if (connector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connector_->clear();
  }
  clear_has_connector();
}
inline const ::std::string& RelayMsg::connector() const {
  // @@protoc_insertion_point(field_get:pms.RelayMsg.connector)
  return *connector_;
}
inline void RelayMsg::set_connector(const ::std::string& value) {
  set_has_connector();
  if (connector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connector_ = new ::std::string;
  }
  connector_->assign(value);
  // @@protoc_insertion_point(field_set:pms.RelayMsg.connector)
}
inline void RelayMsg::set_connector(const char* value) {
  set_has_connector();
  if (connector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connector_ = new ::std::string;
  }
  connector_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.RelayMsg.connector)
}
inline void RelayMsg::set_connector(const char* value, size_t size) {
  set_has_connector();
  if (connector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connector_ = new ::std::string;
  }
  connector_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.RelayMsg.connector)
}
inline ::std::string* RelayMsg::mutable_connector() {
  set_has_connector();
  if (connector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connector_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.RelayMsg.connector)
  return connector_;
}
inline ::std::string* RelayMsg::release_connector() {
  clear_has_connector();
  if (connector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = connector_;
    connector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RelayMsg::set_allocated_connector(::std::string* connector) {
  if (connector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete connector_;
  }
  if (connector) {
    set_has_connector();
    connector_ = connector;
  } else {
    clear_has_connector();
    connector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.RelayMsg.connector)
}

// optional bytes content = 4;
inline bool RelayMsg::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelayMsg::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelayMsg::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelayMsg::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& RelayMsg::content() const {
  // @@protoc_insertion_point(field_get:pms.RelayMsg.content)
  return *content_;
}
inline void RelayMsg::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:pms.RelayMsg.content)
}
inline void RelayMsg::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.RelayMsg.content)
}
inline void RelayMsg::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.RelayMsg.content)
}
inline ::std::string* RelayMsg::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.RelayMsg.content)
  return content_;
}
inline ::std::string* RelayMsg::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RelayMsg::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.RelayMsg.content)
}

// optional .pms.ToUser touser = 5;
inline bool RelayMsg::has_touser() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RelayMsg::set_has_touser() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RelayMsg::clear_has_touser() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RelayMsg::clear_touser() {
  if (touser_ != NULL) touser_->::pms::ToUser::Clear();
  clear_has_touser();
}
inline const ::pms::ToUser& RelayMsg::touser() const {
  // @@protoc_insertion_point(field_get:pms.RelayMsg.touser)
  return touser_ != NULL ? *touser_ : *default_instance_->touser_;
}
inline ::pms::ToUser* RelayMsg::mutable_touser() {
  set_has_touser();
  if (touser_ == NULL) touser_ = new ::pms::ToUser;
  // @@protoc_insertion_point(field_mutable:pms.RelayMsg.touser)
  return touser_;
}
inline ::pms::ToUser* RelayMsg::release_touser() {
  clear_has_touser();
  ::pms::ToUser* temp = touser_;
  touser_ = NULL;
  return temp;
}
inline void RelayMsg::set_allocated_touser(::pms::ToUser* touser) {
  delete touser_;
  touser_ = touser;
  if (touser) {
    set_has_touser();
  } else {
    clear_has_touser();
  }
  // @@protoc_insertion_point(field_set_allocated:pms.RelayMsg.touser)
}

// -------------------------------------------------------------------

// TransferMsg

// optional .pms.ETransferType type = 1;
inline bool TransferMsg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferMsg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferMsg::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pms::ETransferType TransferMsg::type() const {
  // @@protoc_insertion_point(field_get:pms.TransferMsg.type)
  return static_cast< ::pms::ETransferType >(type_);
}
inline void TransferMsg::set_type(::pms::ETransferType value) {
  assert(::pms::ETransferType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pms.TransferMsg.type)
}

// optional .pms.ETransferFlag flag = 2 [default = FNOACK];
inline bool TransferMsg::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferMsg::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferMsg::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferMsg::clear_flag() {
  flag_ = 1;
  clear_has_flag();
}
inline ::pms::ETransferFlag TransferMsg::flag() const {
  // @@protoc_insertion_point(field_get:pms.TransferMsg.flag)
  return static_cast< ::pms::ETransferFlag >(flag_);
}
inline void TransferMsg::set_flag(::pms::ETransferFlag value) {
  assert(::pms::ETransferFlag_IsValid(value));
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:pms.TransferMsg.flag)
}

// optional .pms.ETransferPriority priority = 3 [default = PNORMAL];
inline bool TransferMsg::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransferMsg::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransferMsg::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransferMsg::clear_priority() {
  priority_ = 2;
  clear_has_priority();
}
inline ::pms::ETransferPriority TransferMsg::priority() const {
  // @@protoc_insertion_point(field_get:pms.TransferMsg.priority)
  return static_cast< ::pms::ETransferPriority >(priority_);
}
inline void TransferMsg::set_priority(::pms::ETransferPriority value) {
  assert(::pms::ETransferPriority_IsValid(value));
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:pms.TransferMsg.priority)
}

// optional bytes content = 4;
inline bool TransferMsg::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransferMsg::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransferMsg::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransferMsg::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& TransferMsg::content() const {
  // @@protoc_insertion_point(field_get:pms.TransferMsg.content)
  return *content_;
}
inline void TransferMsg::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:pms.TransferMsg.content)
}
inline void TransferMsg::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:pms.TransferMsg.content)
}
inline void TransferMsg::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pms.TransferMsg.content)
}
inline ::std::string* TransferMsg::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pms.TransferMsg.content)
  return content_;
}
inline ::std::string* TransferMsg::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferMsg::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pms.TransferMsg.content)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pms

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sys_5fmsg_2eproto__INCLUDED
