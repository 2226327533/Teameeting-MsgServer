// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common_msg.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "CommonMsg.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CommonMsgRoot

@implementation CommonMsgRoot

@end

#pragma mark - CommonMsgRoot_FileDescriptor

static GPBFileDescriptor *CommonMsgRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pms"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum EServerCmd

GPBEnumDescriptor *EServerCmd_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Clogin\000Csndmsg\000Cgetmsg\000Clogout\000Ckeepaliv"
        "e\000";
    static const int32_t values[] = {
        EServerCmd_Clogin,
        EServerCmd_Csndmsg,
        EServerCmd_Cgetmsg,
        EServerCmd_Clogout,
        EServerCmd_Ckeepalive,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EServerCmd)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EServerCmd_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EServerCmd_IsValidValue(int32_t value__) {
  switch (value__) {
    case EServerCmd_Clogin:
    case EServerCmd_Csndmsg:
    case EServerCmd_Cgetmsg:
    case EServerCmd_Clogout:
    case EServerCmd_Ckeepalive:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EModuleType

GPBEnumDescriptor *EModuleType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Tmeeting\000Tp2P\000Tlive\000Tcallcenter\000";
    static const int32_t values[] = {
        EModuleType_Tmeeting,
        EModuleType_Tp2P,
        EModuleType_Tlive,
        EModuleType_Tcallcenter,
    };
    static const char *extraTextFormatInfo = "\001\001b\002\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EModuleType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EModuleType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EModuleType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EModuleType_Tmeeting:
    case EModuleType_Tp2P:
    case EModuleType_Tlive:
    case EModuleType_Tcallcenter:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MsgReq

@implementation MsgReq

@dynamic hasSvrCmds, svrCmds;
@dynamic hasModType, modType;
@dynamic hasContent, content;

typedef struct MsgReq__storage_ {
  uint32_t _has_storage_[1];
  EServerCmd svrCmds;
  EModuleType modType;
  NSData *content;
} MsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = EServerCmd_Clogin,
        .core.name = "svrCmds",
        .core.dataTypeSpecific.enumDescFunc = EServerCmd_EnumDescriptor,
        .core.number = MsgReq_FieldNumber_SvrCmds,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(MsgReq__storage_, svrCmds),
        .core.flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = EModuleType_Tmeeting,
        .core.name = "modType",
        .core.dataTypeSpecific.enumDescFunc = EModuleType_EnumDescriptor,
        .core.number = MsgReq_FieldNumber_ModType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(MsgReq__storage_, modType),
        .core.flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "content",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MsgReq_FieldNumber_Content,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(MsgReq__storage_, content),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgReq class]
                                     rootClass:[CommonMsgRoot class]
                                          file:CommonMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(MsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgRep

@implementation MsgRep

@dynamic hasSvrCmds, svrCmds;
@dynamic hasModType, modType;
@dynamic hasRspCont, rspCont;
@dynamic hasRspCode, rspCode;

typedef struct MsgRep__storage_ {
  uint32_t _has_storage_[1];
  EServerCmd svrCmds;
  EModuleType modType;
  int32_t rspCode;
  NSData *rspCont;
} MsgRep__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = EServerCmd_Clogin,
        .core.name = "svrCmds",
        .core.dataTypeSpecific.enumDescFunc = EServerCmd_EnumDescriptor,
        .core.number = MsgRep_FieldNumber_SvrCmds,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(MsgRep__storage_, svrCmds),
        .core.flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = EModuleType_Tmeeting,
        .core.name = "modType",
        .core.dataTypeSpecific.enumDescFunc = EModuleType_EnumDescriptor,
        .core.number = MsgRep_FieldNumber_ModType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(MsgRep__storage_, modType),
        .core.flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "rspCont",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MsgRep_FieldNumber_RspCont,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(MsgRep__storage_, rspCont),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "rspCode",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MsgRep_FieldNumber_RspCode,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(MsgRep__storage_, rspCode),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgRep class]
                                     rootClass:[CommonMsgRoot class]
                                          file:CommonMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(MsgRep__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ToUser

@implementation ToUser

@dynamic usersArray, usersArray_Count;

typedef struct ToUser__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
} ToUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = NULL,
        .number = ToUser_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ToUser__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ToUser class]
                                     rootClass:[CommonMsgRoot class]
                                          file:CommonMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ToUser__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
