// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: entity_msg.proto

#ifndef PROTOBUF_entity_5fmsg_2eproto__INCLUDED
#define PROTOBUF_entity_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common_msg.pb.h"
#include "entity_msg_type.pb.h"
// @@protoc_insertion_point(includes)

namespace pms {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_entity_5fmsg_2eproto();
void protobuf_AssignDesc_entity_5fmsg_2eproto();
void protobuf_ShutdownFile_entity_5fmsg_2eproto();

class Entity;
class Keep;
class Login;
class Logout;

// ===================================================================

class Login : public ::google::protobuf::MessageLite {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  static const Login& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Login* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  inline Login* New() const { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string usr_from = 1;
  void clear_usr_from();
  static const int kUsrFromFieldNumber = 1;
  const ::std::string& usr_from() const;
  void set_usr_from(const ::std::string& value);
  void set_usr_from(const char* value);
  void set_usr_from(const char* value, size_t size);
  ::std::string* mutable_usr_from();
  ::std::string* release_usr_from();
  void set_allocated_usr_from(::std::string* usr_from);

  // optional string usr_token = 2;
  void clear_usr_token();
  static const int kUsrTokenFieldNumber = 2;
  const ::std::string& usr_token() const;
  void set_usr_token(const ::std::string& value);
  void set_usr_token(const char* value);
  void set_usr_token(const char* value, size_t size);
  ::std::string* mutable_usr_token();
  ::std::string* release_usr_token();
  void set_allocated_usr_token(::std::string* usr_token);

  // optional string usr_nname = 3;
  void clear_usr_nname();
  static const int kUsrNnameFieldNumber = 3;
  const ::std::string& usr_nname() const;
  void set_usr_nname(const ::std::string& value);
  void set_usr_nname(const char* value);
  void set_usr_nname(const char* value, size_t size);
  ::std::string* mutable_usr_nname();
  ::std::string* release_usr_nname();
  void set_allocated_usr_nname(::std::string* usr_nname);

  // @@protoc_insertion_point(class_scope:pms.Login)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr usr_from_;
  ::google::protobuf::internal::ArenaStringPtr usr_token_;
  ::google::protobuf::internal::ArenaStringPtr usr_nname_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_entity_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_entity_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_entity_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_entity_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class Logout : public ::google::protobuf::MessageLite {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }

  static const Logout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Logout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Logout* other);

  // implements Message ----------------------------------------------

  inline Logout* New() const { return New(NULL); }

  Logout* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Logout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string usr_from = 1;
  void clear_usr_from();
  static const int kUsrFromFieldNumber = 1;
  const ::std::string& usr_from() const;
  void set_usr_from(const ::std::string& value);
  void set_usr_from(const char* value);
  void set_usr_from(const char* value, size_t size);
  ::std::string* mutable_usr_from();
  ::std::string* release_usr_from();
  void set_allocated_usr_from(::std::string* usr_from);

  // optional string usr_token = 2;
  void clear_usr_token();
  static const int kUsrTokenFieldNumber = 2;
  const ::std::string& usr_token() const;
  void set_usr_token(const ::std::string& value);
  void set_usr_token(const char* value);
  void set_usr_token(const char* value, size_t size);
  ::std::string* mutable_usr_token();
  ::std::string* release_usr_token();
  void set_allocated_usr_token(::std::string* usr_token);

  // @@protoc_insertion_point(class_scope:pms.Logout)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr usr_from_;
  ::google::protobuf::internal::ArenaStringPtr usr_token_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_entity_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_entity_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_entity_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_entity_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Logout* default_instance_;
};
// -------------------------------------------------------------------

class Keep : public ::google::protobuf::MessageLite {
 public:
  Keep();
  virtual ~Keep();

  Keep(const Keep& from);

  inline Keep& operator=(const Keep& from) {
    CopyFrom(from);
    return *this;
  }

  static const Keep& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Keep* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Keep* other);

  // implements Message ----------------------------------------------

  inline Keep* New() const { return New(NULL); }

  Keep* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Keep& from);
  void MergeFrom(const Keep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Keep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string usr_from = 1;
  void clear_usr_from();
  static const int kUsrFromFieldNumber = 1;
  const ::std::string& usr_from() const;
  void set_usr_from(const ::std::string& value);
  void set_usr_from(const char* value);
  void set_usr_from(const char* value, size_t size);
  ::std::string* mutable_usr_from();
  ::std::string* release_usr_from();
  void set_allocated_usr_from(::std::string* usr_from);

  // @@protoc_insertion_point(class_scope:pms.Keep)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr usr_from_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_entity_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_entity_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_entity_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_entity_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Keep* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::MessageLite {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }

  static const Entity& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Entity* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Entity* other);

  // implements Message ----------------------------------------------

  inline Entity* New() const { return New(NULL); }

  Entity* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Entity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pms.EMsgHead msg_head = 1;
  void clear_msg_head();
  static const int kMsgHeadFieldNumber = 1;
  ::pms::EMsgHead msg_head() const;
  void set_msg_head(::pms::EMsgHead value);

  // optional .pms.EMsgTag msg_tag = 2;
  void clear_msg_tag();
  static const int kMsgTagFieldNumber = 2;
  ::pms::EMsgTag msg_tag() const;
  void set_msg_tag(::pms::EMsgTag value);

  // optional .pms.EMsgType msg_type = 3;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 3;
  ::pms::EMsgType msg_type() const;
  void set_msg_type(::pms::EMsgType value);

  // optional .pms.EMsgFlag msg_flag = 4;
  void clear_msg_flag();
  static const int kMsgFlagFieldNumber = 4;
  ::pms::EMsgFlag msg_flag() const;
  void set_msg_flag(::pms::EMsgFlag value);

  // optional string usr_from = 5;
  void clear_usr_from();
  static const int kUsrFromFieldNumber = 5;
  const ::std::string& usr_from() const;
  void set_usr_from(const ::std::string& value);
  void set_usr_from(const char* value);
  void set_usr_from(const char* value, size_t size);
  ::std::string* mutable_usr_from();
  ::std::string* release_usr_from();
  void set_allocated_usr_from(::std::string* usr_from);

  // optional string msg_cont = 6;
  void clear_msg_cont();
  static const int kMsgContFieldNumber = 6;
  const ::std::string& msg_cont() const;
  void set_msg_cont(const ::std::string& value);
  void set_msg_cont(const char* value);
  void set_msg_cont(const char* value, size_t size);
  ::std::string* mutable_msg_cont();
  ::std::string* release_msg_cont();
  void set_allocated_msg_cont(::std::string* msg_cont);

  // optional string rom_id = 7;
  void clear_rom_id();
  static const int kRomIdFieldNumber = 7;
  const ::std::string& rom_id() const;
  void set_rom_id(const ::std::string& value);
  void set_rom_id(const char* value);
  void set_rom_id(const char* value, size_t size);
  ::std::string* mutable_rom_id();
  ::std::string* release_rom_id();
  void set_allocated_rom_id(::std::string* rom_id);

  // optional string rom_name = 8;
  void clear_rom_name();
  static const int kRomNameFieldNumber = 8;
  const ::std::string& rom_name() const;
  void set_rom_name(const ::std::string& value);
  void set_rom_name(const char* value);
  void set_rom_name(const char* value, size_t size);
  ::std::string* mutable_rom_name();
  ::std::string* release_rom_name();
  void set_allocated_rom_name(::std::string* rom_name);

  // optional string nck_name = 9;
  void clear_nck_name();
  static const int kNckNameFieldNumber = 9;
  const ::std::string& nck_name() const;
  void set_nck_name(const ::std::string& value);
  void set_nck_name(const char* value);
  void set_nck_name(const char* value, size_t size);
  ::std::string* mutable_nck_name();
  ::std::string* release_nck_name();
  void set_allocated_nck_name(::std::string* nck_name);

  // optional string usr_token = 10;
  void clear_usr_token();
  static const int kUsrTokenFieldNumber = 10;
  const ::std::string& usr_token() const;
  void set_usr_token(const ::std::string& value);
  void set_usr_token(const char* value);
  void set_usr_token(const char* value, size_t size);
  ::std::string* mutable_usr_token();
  ::std::string* release_usr_token();
  void set_allocated_usr_token(::std::string* usr_token);

  // optional sint64 msg_seqs = 11;
  void clear_msg_seqs();
  static const int kMsgSeqsFieldNumber = 11;
  ::google::protobuf::int64 msg_seqs() const;
  void set_msg_seqs(::google::protobuf::int64 value);

  // optional sint32 mem_num = 12;
  void clear_mem_num();
  static const int kMemNumFieldNumber = 12;
  ::google::protobuf::int32 mem_num() const;
  void set_mem_num(::google::protobuf::int32 value);

  // optional .pms.ToUser usr_toto = 13;
  bool has_usr_toto() const;
  void clear_usr_toto();
  static const int kUsrTotoFieldNumber = 13;
  const ::pms::ToUser& usr_toto() const;
  ::pms::ToUser* mutable_usr_toto();
  ::pms::ToUser* release_usr_toto();
  void set_allocated_usr_toto(::pms::ToUser* usr_toto);

  // @@protoc_insertion_point(class_scope:pms.Entity)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  int msg_head_;
  int msg_tag_;
  int msg_type_;
  int msg_flag_;
  ::google::protobuf::internal::ArenaStringPtr usr_from_;
  ::google::protobuf::internal::ArenaStringPtr msg_cont_;
  ::google::protobuf::internal::ArenaStringPtr rom_id_;
  ::google::protobuf::internal::ArenaStringPtr rom_name_;
  ::google::protobuf::internal::ArenaStringPtr nck_name_;
  ::google::protobuf::internal::ArenaStringPtr usr_token_;
  ::google::protobuf::int64 msg_seqs_;
  ::pms::ToUser* usr_toto_;
  ::google::protobuf::int32 mem_num_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_entity_5fmsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_entity_5fmsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_entity_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_entity_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Login

// optional string usr_from = 1;
inline void Login::clear_usr_from() {
  usr_from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::usr_from() const {
  // @@protoc_insertion_point(field_get:pms.Login.usr_from)
  return usr_from_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_usr_from(const ::std::string& value) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Login.usr_from)
}
inline void Login::set_usr_from(const char* value) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Login.usr_from)
}
inline void Login::set_usr_from(const char* value, size_t size) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Login.usr_from)
}
inline ::std::string* Login::mutable_usr_from() {
  
  // @@protoc_insertion_point(field_mutable:pms.Login.usr_from)
  return usr_from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_usr_from() {
  // @@protoc_insertion_point(field_release:pms.Login.usr_from)
  
  return usr_from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_usr_from(::std::string* usr_from) {
  if (usr_from != NULL) {
    
  } else {
    
  }
  usr_from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usr_from);
  // @@protoc_insertion_point(field_set_allocated:pms.Login.usr_from)
}

// optional string usr_token = 2;
inline void Login::clear_usr_token() {
  usr_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::usr_token() const {
  // @@protoc_insertion_point(field_get:pms.Login.usr_token)
  return usr_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_usr_token(const ::std::string& value) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Login.usr_token)
}
inline void Login::set_usr_token(const char* value) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Login.usr_token)
}
inline void Login::set_usr_token(const char* value, size_t size) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Login.usr_token)
}
inline ::std::string* Login::mutable_usr_token() {
  
  // @@protoc_insertion_point(field_mutable:pms.Login.usr_token)
  return usr_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_usr_token() {
  // @@protoc_insertion_point(field_release:pms.Login.usr_token)
  
  return usr_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_usr_token(::std::string* usr_token) {
  if (usr_token != NULL) {
    
  } else {
    
  }
  usr_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usr_token);
  // @@protoc_insertion_point(field_set_allocated:pms.Login.usr_token)
}

// optional string usr_nname = 3;
inline void Login::clear_usr_nname() {
  usr_nname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::usr_nname() const {
  // @@protoc_insertion_point(field_get:pms.Login.usr_nname)
  return usr_nname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_usr_nname(const ::std::string& value) {
  
  usr_nname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Login.usr_nname)
}
inline void Login::set_usr_nname(const char* value) {
  
  usr_nname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Login.usr_nname)
}
inline void Login::set_usr_nname(const char* value, size_t size) {
  
  usr_nname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Login.usr_nname)
}
inline ::std::string* Login::mutable_usr_nname() {
  
  // @@protoc_insertion_point(field_mutable:pms.Login.usr_nname)
  return usr_nname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_usr_nname() {
  // @@protoc_insertion_point(field_release:pms.Login.usr_nname)
  
  return usr_nname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_usr_nname(::std::string* usr_nname) {
  if (usr_nname != NULL) {
    
  } else {
    
  }
  usr_nname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usr_nname);
  // @@protoc_insertion_point(field_set_allocated:pms.Login.usr_nname)
}

// -------------------------------------------------------------------

// Logout

// optional string usr_from = 1;
inline void Logout::clear_usr_from() {
  usr_from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Logout::usr_from() const {
  // @@protoc_insertion_point(field_get:pms.Logout.usr_from)
  return usr_from_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Logout::set_usr_from(const ::std::string& value) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Logout.usr_from)
}
inline void Logout::set_usr_from(const char* value) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Logout.usr_from)
}
inline void Logout::set_usr_from(const char* value, size_t size) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Logout.usr_from)
}
inline ::std::string* Logout::mutable_usr_from() {
  
  // @@protoc_insertion_point(field_mutable:pms.Logout.usr_from)
  return usr_from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Logout::release_usr_from() {
  // @@protoc_insertion_point(field_release:pms.Logout.usr_from)
  
  return usr_from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Logout::set_allocated_usr_from(::std::string* usr_from) {
  if (usr_from != NULL) {
    
  } else {
    
  }
  usr_from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usr_from);
  // @@protoc_insertion_point(field_set_allocated:pms.Logout.usr_from)
}

// optional string usr_token = 2;
inline void Logout::clear_usr_token() {
  usr_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Logout::usr_token() const {
  // @@protoc_insertion_point(field_get:pms.Logout.usr_token)
  return usr_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Logout::set_usr_token(const ::std::string& value) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Logout.usr_token)
}
inline void Logout::set_usr_token(const char* value) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Logout.usr_token)
}
inline void Logout::set_usr_token(const char* value, size_t size) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Logout.usr_token)
}
inline ::std::string* Logout::mutable_usr_token() {
  
  // @@protoc_insertion_point(field_mutable:pms.Logout.usr_token)
  return usr_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Logout::release_usr_token() {
  // @@protoc_insertion_point(field_release:pms.Logout.usr_token)
  
  return usr_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Logout::set_allocated_usr_token(::std::string* usr_token) {
  if (usr_token != NULL) {
    
  } else {
    
  }
  usr_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usr_token);
  // @@protoc_insertion_point(field_set_allocated:pms.Logout.usr_token)
}

// -------------------------------------------------------------------

// Keep

// optional string usr_from = 1;
inline void Keep::clear_usr_from() {
  usr_from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Keep::usr_from() const {
  // @@protoc_insertion_point(field_get:pms.Keep.usr_from)
  return usr_from_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Keep::set_usr_from(const ::std::string& value) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Keep.usr_from)
}
inline void Keep::set_usr_from(const char* value) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Keep.usr_from)
}
inline void Keep::set_usr_from(const char* value, size_t size) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Keep.usr_from)
}
inline ::std::string* Keep::mutable_usr_from() {
  
  // @@protoc_insertion_point(field_mutable:pms.Keep.usr_from)
  return usr_from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Keep::release_usr_from() {
  // @@protoc_insertion_point(field_release:pms.Keep.usr_from)
  
  return usr_from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Keep::set_allocated_usr_from(::std::string* usr_from) {
  if (usr_from != NULL) {
    
  } else {
    
  }
  usr_from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usr_from);
  // @@protoc_insertion_point(field_set_allocated:pms.Keep.usr_from)
}

// -------------------------------------------------------------------

// Entity

// optional .pms.EMsgHead msg_head = 1;
inline void Entity::clear_msg_head() {
  msg_head_ = 0;
}
inline ::pms::EMsgHead Entity::msg_head() const {
  // @@protoc_insertion_point(field_get:pms.Entity.msg_head)
  return static_cast< ::pms::EMsgHead >(msg_head_);
}
inline void Entity::set_msg_head(::pms::EMsgHead value) {
  
  msg_head_ = value;
  // @@protoc_insertion_point(field_set:pms.Entity.msg_head)
}

// optional .pms.EMsgTag msg_tag = 2;
inline void Entity::clear_msg_tag() {
  msg_tag_ = 0;
}
inline ::pms::EMsgTag Entity::msg_tag() const {
  // @@protoc_insertion_point(field_get:pms.Entity.msg_tag)
  return static_cast< ::pms::EMsgTag >(msg_tag_);
}
inline void Entity::set_msg_tag(::pms::EMsgTag value) {
  
  msg_tag_ = value;
  // @@protoc_insertion_point(field_set:pms.Entity.msg_tag)
}

// optional .pms.EMsgType msg_type = 3;
inline void Entity::clear_msg_type() {
  msg_type_ = 0;
}
inline ::pms::EMsgType Entity::msg_type() const {
  // @@protoc_insertion_point(field_get:pms.Entity.msg_type)
  return static_cast< ::pms::EMsgType >(msg_type_);
}
inline void Entity::set_msg_type(::pms::EMsgType value) {
  
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:pms.Entity.msg_type)
}

// optional .pms.EMsgFlag msg_flag = 4;
inline void Entity::clear_msg_flag() {
  msg_flag_ = 0;
}
inline ::pms::EMsgFlag Entity::msg_flag() const {
  // @@protoc_insertion_point(field_get:pms.Entity.msg_flag)
  return static_cast< ::pms::EMsgFlag >(msg_flag_);
}
inline void Entity::set_msg_flag(::pms::EMsgFlag value) {
  
  msg_flag_ = value;
  // @@protoc_insertion_point(field_set:pms.Entity.msg_flag)
}

// optional string usr_from = 5;
inline void Entity::clear_usr_from() {
  usr_from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Entity::usr_from() const {
  // @@protoc_insertion_point(field_get:pms.Entity.usr_from)
  return usr_from_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_usr_from(const ::std::string& value) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Entity.usr_from)
}
inline void Entity::set_usr_from(const char* value) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Entity.usr_from)
}
inline void Entity::set_usr_from(const char* value, size_t size) {
  
  usr_from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Entity.usr_from)
}
inline ::std::string* Entity::mutable_usr_from() {
  
  // @@protoc_insertion_point(field_mutable:pms.Entity.usr_from)
  return usr_from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_usr_from() {
  // @@protoc_insertion_point(field_release:pms.Entity.usr_from)
  
  return usr_from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_usr_from(::std::string* usr_from) {
  if (usr_from != NULL) {
    
  } else {
    
  }
  usr_from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usr_from);
  // @@protoc_insertion_point(field_set_allocated:pms.Entity.usr_from)
}

// optional string msg_cont = 6;
inline void Entity::clear_msg_cont() {
  msg_cont_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Entity::msg_cont() const {
  // @@protoc_insertion_point(field_get:pms.Entity.msg_cont)
  return msg_cont_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_msg_cont(const ::std::string& value) {
  
  msg_cont_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Entity.msg_cont)
}
inline void Entity::set_msg_cont(const char* value) {
  
  msg_cont_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Entity.msg_cont)
}
inline void Entity::set_msg_cont(const char* value, size_t size) {
  
  msg_cont_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Entity.msg_cont)
}
inline ::std::string* Entity::mutable_msg_cont() {
  
  // @@protoc_insertion_point(field_mutable:pms.Entity.msg_cont)
  return msg_cont_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_msg_cont() {
  // @@protoc_insertion_point(field_release:pms.Entity.msg_cont)
  
  return msg_cont_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_msg_cont(::std::string* msg_cont) {
  if (msg_cont != NULL) {
    
  } else {
    
  }
  msg_cont_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg_cont);
  // @@protoc_insertion_point(field_set_allocated:pms.Entity.msg_cont)
}

// optional string rom_id = 7;
inline void Entity::clear_rom_id() {
  rom_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Entity::rom_id() const {
  // @@protoc_insertion_point(field_get:pms.Entity.rom_id)
  return rom_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_rom_id(const ::std::string& value) {
  
  rom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Entity.rom_id)
}
inline void Entity::set_rom_id(const char* value) {
  
  rom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Entity.rom_id)
}
inline void Entity::set_rom_id(const char* value, size_t size) {
  
  rom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Entity.rom_id)
}
inline ::std::string* Entity::mutable_rom_id() {
  
  // @@protoc_insertion_point(field_mutable:pms.Entity.rom_id)
  return rom_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_rom_id() {
  // @@protoc_insertion_point(field_release:pms.Entity.rom_id)
  
  return rom_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_rom_id(::std::string* rom_id) {
  if (rom_id != NULL) {
    
  } else {
    
  }
  rom_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rom_id);
  // @@protoc_insertion_point(field_set_allocated:pms.Entity.rom_id)
}

// optional string rom_name = 8;
inline void Entity::clear_rom_name() {
  rom_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Entity::rom_name() const {
  // @@protoc_insertion_point(field_get:pms.Entity.rom_name)
  return rom_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_rom_name(const ::std::string& value) {
  
  rom_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Entity.rom_name)
}
inline void Entity::set_rom_name(const char* value) {
  
  rom_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Entity.rom_name)
}
inline void Entity::set_rom_name(const char* value, size_t size) {
  
  rom_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Entity.rom_name)
}
inline ::std::string* Entity::mutable_rom_name() {
  
  // @@protoc_insertion_point(field_mutable:pms.Entity.rom_name)
  return rom_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_rom_name() {
  // @@protoc_insertion_point(field_release:pms.Entity.rom_name)
  
  return rom_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_rom_name(::std::string* rom_name) {
  if (rom_name != NULL) {
    
  } else {
    
  }
  rom_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rom_name);
  // @@protoc_insertion_point(field_set_allocated:pms.Entity.rom_name)
}

// optional string nck_name = 9;
inline void Entity::clear_nck_name() {
  nck_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Entity::nck_name() const {
  // @@protoc_insertion_point(field_get:pms.Entity.nck_name)
  return nck_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_nck_name(const ::std::string& value) {
  
  nck_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Entity.nck_name)
}
inline void Entity::set_nck_name(const char* value) {
  
  nck_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Entity.nck_name)
}
inline void Entity::set_nck_name(const char* value, size_t size) {
  
  nck_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Entity.nck_name)
}
inline ::std::string* Entity::mutable_nck_name() {
  
  // @@protoc_insertion_point(field_mutable:pms.Entity.nck_name)
  return nck_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_nck_name() {
  // @@protoc_insertion_point(field_release:pms.Entity.nck_name)
  
  return nck_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_nck_name(::std::string* nck_name) {
  if (nck_name != NULL) {
    
  } else {
    
  }
  nck_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nck_name);
  // @@protoc_insertion_point(field_set_allocated:pms.Entity.nck_name)
}

// optional string usr_token = 10;
inline void Entity::clear_usr_token() {
  usr_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Entity::usr_token() const {
  // @@protoc_insertion_point(field_get:pms.Entity.usr_token)
  return usr_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_usr_token(const ::std::string& value) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pms.Entity.usr_token)
}
inline void Entity::set_usr_token(const char* value) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pms.Entity.usr_token)
}
inline void Entity::set_usr_token(const char* value, size_t size) {
  
  usr_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pms.Entity.usr_token)
}
inline ::std::string* Entity::mutable_usr_token() {
  
  // @@protoc_insertion_point(field_mutable:pms.Entity.usr_token)
  return usr_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_usr_token() {
  // @@protoc_insertion_point(field_release:pms.Entity.usr_token)
  
  return usr_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_usr_token(::std::string* usr_token) {
  if (usr_token != NULL) {
    
  } else {
    
  }
  usr_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usr_token);
  // @@protoc_insertion_point(field_set_allocated:pms.Entity.usr_token)
}

// optional sint64 msg_seqs = 11;
inline void Entity::clear_msg_seqs() {
  msg_seqs_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Entity::msg_seqs() const {
  // @@protoc_insertion_point(field_get:pms.Entity.msg_seqs)
  return msg_seqs_;
}
inline void Entity::set_msg_seqs(::google::protobuf::int64 value) {
  
  msg_seqs_ = value;
  // @@protoc_insertion_point(field_set:pms.Entity.msg_seqs)
}

// optional sint32 mem_num = 12;
inline void Entity::clear_mem_num() {
  mem_num_ = 0;
}
inline ::google::protobuf::int32 Entity::mem_num() const {
  // @@protoc_insertion_point(field_get:pms.Entity.mem_num)
  return mem_num_;
}
inline void Entity::set_mem_num(::google::protobuf::int32 value) {
  
  mem_num_ = value;
  // @@protoc_insertion_point(field_set:pms.Entity.mem_num)
}

// optional .pms.ToUser usr_toto = 13;
inline bool Entity::has_usr_toto() const {
  return !_is_default_instance_ && usr_toto_ != NULL;
}
inline void Entity::clear_usr_toto() {
  if (GetArenaNoVirtual() == NULL && usr_toto_ != NULL) delete usr_toto_;
  usr_toto_ = NULL;
}
inline const ::pms::ToUser& Entity::usr_toto() const {
  // @@protoc_insertion_point(field_get:pms.Entity.usr_toto)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return usr_toto_ != NULL ? *usr_toto_ : *default_instance().usr_toto_;
#else
  return usr_toto_ != NULL ? *usr_toto_ : *default_instance_->usr_toto_;
#endif
}
inline ::pms::ToUser* Entity::mutable_usr_toto() {
  
  if (usr_toto_ == NULL) {
    usr_toto_ = new ::pms::ToUser;
  }
  // @@protoc_insertion_point(field_mutable:pms.Entity.usr_toto)
  return usr_toto_;
}
inline ::pms::ToUser* Entity::release_usr_toto() {
  // @@protoc_insertion_point(field_release:pms.Entity.usr_toto)
  
  ::pms::ToUser* temp = usr_toto_;
  usr_toto_ = NULL;
  return temp;
}
inline void Entity::set_allocated_usr_toto(::pms::ToUser* usr_toto) {
  delete usr_toto_;
  usr_toto_ = usr_toto;
  if (usr_toto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pms.Entity.usr_toto)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pms

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_entity_5fmsg_2eproto__INCLUDED
