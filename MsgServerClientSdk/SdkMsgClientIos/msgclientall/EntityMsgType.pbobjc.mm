// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: entity_msg_type.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "EntityMsgType.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - EntityMsgTypeRoot

@implementation EntityMsgTypeRoot

@end

#pragma mark - Enum EMsgType

GPBEnumDescriptor *EMsgType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ttxt\000Tfil\000Tpic\000Taud\000Tvid\000";
    static const int32_t values[] = {
        EMsgType_Ttxt,
        EMsgType_Tfil,
        EMsgType_Tpic,
        EMsgType_Taud,
        EMsgType_Tvid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EMsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EMsgType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EMsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EMsgType_Ttxt:
    case EMsgType_Tfil:
    case EMsgType_Tpic:
    case EMsgType_Taud:
    case EMsgType_Tvid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EMsgTag

GPBEnumDescriptor *EMsgTag_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Tenter\000Tleave\000Tchat\000Tnotify\000Tssseqn\000Tssd"
        "ata\000";
    static const int32_t values[] = {
        EMsgTag_Tenter,
        EMsgTag_Tleave,
        EMsgTag_Tchat,
        EMsgTag_Tnotify,
        EMsgTag_Tssseqn,
        EMsgTag_Tssdata,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EMsgTag)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EMsgTag_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EMsgTag_IsValidValue(int32_t value__) {
  switch (value__) {
    case EMsgTag_Tenter:
    case EMsgTag_Tleave:
    case EMsgTag_Tchat:
    case EMsgTag_Tnotify:
    case EMsgTag_Tssseqn:
    case EMsgTag_Tssdata:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EMsgHead

GPBEnumDescriptor *EMsgHead_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Hsnd\000Hget\000";
    static const int32_t values[] = {
        EMsgHead_Hsnd,
        EMsgHead_Hget,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EMsgHead)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EMsgHead_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EMsgHead_IsValidValue(int32_t value__) {
  switch (value__) {
    case EMsgHead_Hsnd:
    case EMsgHead_Hget:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
