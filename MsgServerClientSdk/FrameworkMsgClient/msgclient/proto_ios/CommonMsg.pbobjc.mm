// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common_msg.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "CommonMsg.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CommonMsgRoot

@implementation CommonMsgRoot

@end

#pragma mark - CommonMsgRoot_FileDescriptor

static GPBFileDescriptor *CommonMsgRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pms"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum EServerCmd

GPBEnumDescriptor *EServerCmd_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Clogin\000Csndmsg\000Cgetmsg\000Clogout\000Ckeepaliv"
        "e\000Cseqn\000Cdata\000Csntfseqn\000Cpgetdata\000Csyncs"
        "eqn\000Csseqn4Data\000Csyncdata\000Csyncgroupdata"
        "\000Cnewmsg\000Cnewmsgseqn\000Cnewmsgdata\000Cgroupn"
        "otify\000Ccreateseqn\000Cdeleteseqn\000Cupdateset"
        "ting\000";
    static const int32_t values[] = {
        EServerCmd_Clogin,
        EServerCmd_Csndmsg,
        EServerCmd_Cgetmsg,
        EServerCmd_Clogout,
        EServerCmd_Ckeepalive,
        EServerCmd_Cseqn,
        EServerCmd_Cdata,
        EServerCmd_Csntfseqn,
        EServerCmd_Cpgetdata,
        EServerCmd_Csyncseqn,
        EServerCmd_Csseqn4Data,
        EServerCmd_Csyncdata,
        EServerCmd_Csyncgroupdata,
        EServerCmd_Cnewmsg,
        EServerCmd_Cnewmsgseqn,
        EServerCmd_Cnewmsgdata,
        EServerCmd_Cgroupnotify,
        EServerCmd_Ccreateseqn,
        EServerCmd_Cdeleteseqn,
        EServerCmd_Cupdatesetting,
    };
    static const char *extraTextFormatInfo = "\001\nf\002c\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EServerCmd)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EServerCmd_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EServerCmd_IsValidValue(int32_t value__) {
  switch (value__) {
    case EServerCmd_Clogin:
    case EServerCmd_Csndmsg:
    case EServerCmd_Cgetmsg:
    case EServerCmd_Clogout:
    case EServerCmd_Ckeepalive:
    case EServerCmd_Cseqn:
    case EServerCmd_Cdata:
    case EServerCmd_Csntfseqn:
    case EServerCmd_Cpgetdata:
    case EServerCmd_Csyncseqn:
    case EServerCmd_Csseqn4Data:
    case EServerCmd_Csyncdata:
    case EServerCmd_Csyncgroupdata:
    case EServerCmd_Cnewmsg:
    case EServerCmd_Cnewmsgseqn:
    case EServerCmd_Cnewmsgdata:
    case EServerCmd_Cgroupnotify:
    case EServerCmd_Ccreateseqn:
    case EServerCmd_Cdeleteseqn:
    case EServerCmd_Cupdatesetting:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EModuleType

GPBEnumDescriptor *EModuleType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Tinvalid0\000Tinvalid1\000Tmeeting\000Tp2P\000Tlive\000"
        "Tcallcenter\000Tlogical\000Tsequence\000Tstorage\000"
        "Tgrpnotify\000Tpusher\000";
    static const int32_t values[] = {
        EModuleType_Tinvalid0,
        EModuleType_Tinvalid1,
        EModuleType_Tmeeting,
        EModuleType_Tp2P,
        EModuleType_Tlive,
        EModuleType_Tcallcenter,
        EModuleType_Tlogical,
        EModuleType_Tsequence,
        EModuleType_Tstorage,
        EModuleType_Tgrpnotify,
        EModuleType_Tpusher,
    };
    static const char *extraTextFormatInfo = "\001\003b\002\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EModuleType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EModuleType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EModuleType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EModuleType_Tinvalid0:
    case EModuleType_Tinvalid1:
    case EModuleType_Tmeeting:
    case EModuleType_Tp2P:
    case EModuleType_Tlive:
    case EModuleType_Tcallcenter:
    case EModuleType_Tlogical:
    case EModuleType_Tsequence:
    case EModuleType_Tstorage:
    case EModuleType_Tgrpnotify:
    case EModuleType_Tpusher:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EMsgFlag

GPBEnumDescriptor *EMsgFlag_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Finvalid\000Fsingle\000Fmulti\000Fgroup\000";
    static const int32_t values[] = {
        EMsgFlag_Finvalid,
        EMsgFlag_Fsingle,
        EMsgFlag_Fmulti,
        EMsgFlag_Fgroup,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EMsgFlag)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EMsgFlag_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EMsgFlag_IsValidValue(int32_t value__) {
  switch (value__) {
    case EMsgFlag_Finvalid:
    case EMsgFlag_Fsingle:
    case EMsgFlag_Fmulti:
    case EMsgFlag_Fgroup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EMsgRole

GPBEnumDescriptor *EMsgRole_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Rsender\000Rrecver\000";
    static const int32_t values[] = {
        EMsgRole_Rsender,
        EMsgRole_Rrecver,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EMsgRole)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EMsgRole_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EMsgRole_IsValidValue(int32_t value__) {
  switch (value__) {
    case EMsgRole_Rsender:
    case EMsgRole_Rrecver:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EMsgRType

GPBEnumDescriptor *EMsgRType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Rreadlocal\000Rreadremote\000";
    static const int32_t values[] = {
        EMsgRType_Rreadlocal,
        EMsgRType_Rreadremote,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EMsgRType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EMsgRType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EMsgRType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EMsgRType_Rreadlocal:
    case EMsgRType_Rreadremote:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MsgReq

@implementation MsgReq

@dynamic svrCmds;
@dynamic modType;
@dynamic content;

typedef struct MsgReq__storage_ {
  uint32_t _has_storage_[1];
  EServerCmd svrCmds;
  EModuleType modType;
  NSData *content;
} MsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "svrCmds",
        .dataTypeSpecific.enumDescFunc = EServerCmd_EnumDescriptor,
        .number = MsgReq_FieldNumber_SvrCmds,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgReq__storage_, svrCmds),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "modType",
        .dataTypeSpecific.enumDescFunc = EModuleType_EnumDescriptor,
        .number = MsgReq_FieldNumber_ModType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgReq__storage_, modType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = MsgReq_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgReq__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgReq class]
                                     rootClass:[CommonMsgRoot class]
                                          file:CommonMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgReq__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MsgReq_SvrCmds_RawValue(MsgReq *message) {
  GPBDescriptor *descriptor = [MsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgReq_FieldNumber_SvrCmds];
  return GPBGetMessageInt32Field(message, field);
}

void SetMsgReq_SvrCmds_RawValue(MsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [MsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgReq_FieldNumber_SvrCmds];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MsgReq_ModType_RawValue(MsgReq *message) {
  GPBDescriptor *descriptor = [MsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgReq_FieldNumber_ModType];
  return GPBGetMessageInt32Field(message, field);
}

void SetMsgReq_ModType_RawValue(MsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [MsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgReq_FieldNumber_ModType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - MsgRep

@implementation MsgRep

@dynamic svrCmds;
@dynamic modType;
@dynamic rspCont;
@dynamic rspCode;

typedef struct MsgRep__storage_ {
  uint32_t _has_storage_[1];
  EServerCmd svrCmds;
  EModuleType modType;
  int32_t rspCode;
  NSData *rspCont;
} MsgRep__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "svrCmds",
        .dataTypeSpecific.enumDescFunc = EServerCmd_EnumDescriptor,
        .number = MsgRep_FieldNumber_SvrCmds,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgRep__storage_, svrCmds),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "modType",
        .dataTypeSpecific.enumDescFunc = EModuleType_EnumDescriptor,
        .number = MsgRep_FieldNumber_ModType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgRep__storage_, modType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rspCont",
        .dataTypeSpecific.className = NULL,
        .number = MsgRep_FieldNumber_RspCont,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgRep__storage_, rspCont),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rspCode",
        .dataTypeSpecific.className = NULL,
        .number = MsgRep_FieldNumber_RspCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MsgRep__storage_, rspCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgRep class]
                                     rootClass:[CommonMsgRoot class]
                                          file:CommonMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgRep__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MsgRep_SvrCmds_RawValue(MsgRep *message) {
  GPBDescriptor *descriptor = [MsgRep descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgRep_FieldNumber_SvrCmds];
  return GPBGetMessageInt32Field(message, field);
}

void SetMsgRep_SvrCmds_RawValue(MsgRep *message, int32_t value) {
  GPBDescriptor *descriptor = [MsgRep descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgRep_FieldNumber_SvrCmds];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MsgRep_ModType_RawValue(MsgRep *message) {
  GPBDescriptor *descriptor = [MsgRep descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgRep_FieldNumber_ModType];
  return GPBGetMessageInt32Field(message, field);
}

void SetMsgRep_ModType_RawValue(MsgRep *message, int32_t value) {
  GPBDescriptor *descriptor = [MsgRep descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgRep_FieldNumber_ModType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ToUser

@implementation ToUser

@dynamic usersArray, usersArray_Count;

typedef struct ToUser__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
} ToUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = NULL,
        .number = ToUser_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ToUser__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ToUser class]
                                     rootClass:[CommonMsgRoot class]
                                          file:CommonMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ToUser__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
